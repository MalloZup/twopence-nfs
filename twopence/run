#!/usr/bin/python
#
# Test program to verify that NFS client and server function properly
#
# Copyright (C) 2015 Olaf Kirch <okir@suse.de>
#

import sys
import suselog
import twopence
import susetest

journal = None
server = None
client1 = None
client2 = None

nfstool	= "/usr/bin/nfs"

def setup():
	global client1, client2, server, journal

	config = susetest.Config()
	reportPath = config.value("report")
	if not reportPath:
		reportPath = "report.xml"
	journal = suselog.Journal("nfs", path = reportPath);

	journal.beginGroup("setup")

	server = config.target("server")
	client1 = config.target("client1")

	try:
		client2 = config.target("client2")
	except:
		journal.info("No second client defined, skipping all two-client test cases")

	if not client1.ipaddr:
		journal.fatal("No IP address set for client1");
	if client2 and not client2.ipaddr:
		journal.fatal("No IP address set for client2");
	if not server.ipaddr:
		journal.fatal("No IP address set for server");

	# FIXME: we should also verify the host names of these nodes

def __nfs_run(target, command, timeout = -1):
	cmd = twopence.Command(command)
	if timeout >= 0:
		# Ugly, but needed until upstream twopence is fixed
		try:
			cmd.timeout = timeout;
		except:
			timeout = str(timeout);
		try:
			cmd.timeout = timeout;
		except:
			journal.warning("Unable to set command timeout; expect issues")

	journal.info(target.name + ": " + cmd.commandline)
	try:
		status = target.run(cmd)
	except:
		journal.failure("command execution failed with exception")
		status = twopence.Status(256, bytearray(), bytearray())

	if not status:
		journal.info("command failed: " + status.message)

	journal.recordStdout(status.stdout);
	if status.stdout != status.stderr:
		journal.recordStderr(status.stderr);
	
	return status

def log_buffered_output(desc, data):
	# data is usually a bytearray
	if len(data) == 0:
		return

	journal.failure(desc + ":")
	for line in str(data).split("\n"):
		journal.failure(line);

def nfs_run(target, command):
	status = __nfs_run(target, command)
	if not(status):
		journal.failure("command \"" + command + "\" failed: " + status.message);
	return status

##################################################################
# Add a line to a hosts file
##################################################################
def nfs_add_hostsfile(node, addr, fqdn):
	alias = fqdn.split('.')[0]
	if alias != fqdn:
		line = "%s %s %s" % (addr, fqdn, alias)
	else:
		line = "%s %s" % (addr, fqdn)

	journal.beginTest(None, "update hosts file on %s" % node.name)
	status = node.recvfile("/etc/hosts");
	if not status:
		journal.failure("unable to download hosts file");
		return False;

	for l in str(status.buffer).split('\n'):
		if l == line:
			journal.info("requested line already in hosts file, nothing to be done")
			journal.success()
			return True

	buffer = status.buffer + "\n" + line + "\n"
	if not node.sendfile("/etc/hosts", data = buffer):
		journal.failure("unable to upload modified hosts file");
		return False

	journal.success();
	return True

##################################################################
# Initialize RPC tests and run some initial sanity checks
##################################################################
def init_server(node):
	global client1, client2;

	journal.beginGroup("server-init", "enable NFS server")

	nfs_init_common(node)

	journal.beginTest(None, "enable nfsd and rpcbind on server")
	nfs_run(node, "/bin/rm -rf /srv/nfs/dir{1,2,3,4}")
	nfs_run(node, "/bin/mkdir -p -m 777 /srv/nfs/dir{1,2,3,4}")

	if node.run("test -x /usr/bin/systemctl"):
		use_systemd = True
		nfs_run(node, "/etc/init.d/nfsserver start")
		nfs_run(node, "/usr/bin/systemctl enable nfsserver");
	else:
		nfs_run(node, "insserv -d nfsserver");
		nfs_run(node, "/etc/init.d/nfsserver start")


	# Help: add the two clients to the server's hosts file
	nfs_add_hostsfile(node, client1.ipaddr, "client1.testing.opensuse.org")

	if client2:
		nfs_add_hostsfile(node, client2.ipaddr, "client2.testing.opensuse.org")

	journal.finishGroup()

##################################################################
# Initialize an NFS client node
##################################################################
def init_client(node):
	global server;

	journal.beginTest(None, "initialize client %s" % node.name)

	nfs_init_common(node)

	nfs_add_hostsfile(node, server.ipaddr, "nfs-server.testing.opensuse.org")
	if not __nfs_run(node, "/usr/sbin/showmount -e nfs-server.testing.opensuse.org"):
		journal.fatal("Unable to contact NFS server")
		return False

	mtab = __nfs_mtab_get(node)
	for dir in ["dir1", "dir2", "dir3", "dir4"]:
		clientdir = __nfs_client_file(dir);
		if __nfs_mtab_find_mountpoint(mtab, clientdir):
			journal.info("Unmounting dir left mounted from previous test run")
			nfs_do_umount(node, dir);

		if not __nfs_run(node, "test -d %s || mkdir -p %s" % (clientdir, clientdir)):
			journal.fatal( "Failed to set up NFS mount points")
			return False

	# nfs_write_idmap_conf(node)

	# A simple start is not enough to make it start all helper services
	if not __nfs_run(node, "/etc/init.d/nfs force-start"):
		journal.fatal("NFS start script exited with error")
		return False;

	# In current kernels, the default is to not perform ID mapping
	# in NFSv4 unless auth flavors other than AUTH_SYS are used.
	# Since we want to use it, enable it.
	# node.sendfile(remotefile = "/sys/module/nfs/parameters/nfs4_disable_idmapping", data = "N")

	return True

##################################################################
# Common initialization code for clients and server
##################################################################
def nfs_init_common(node):
	if node.run("test -x /usr/bin/systemctl"):
		nfs_run(node, "/usr/bin/systemctl enable rpcbind.socket")
		nfs_run(node, "/usr/bin/systemctl start rpcbind.socket")
	else:
		nfs_run(node, "insserv -d rpcbind")
		nfs_run(node, "/etc/init.d/rpcbind start")

	# exercise your shift key, stop the firewall
	nfs_run(node, "rcSuSEfirewall2 stop")


##################################################################
# Update the idmapd.conf file on the given node
##################################################################
def nfs_write_idmap_conf(node):

	idmapd_conf = '''
[General]

Verbosity = 15
Pipefs-Directory = /var/lib/nfs/rpc_pipefs
Domain = testing.opensuse.org

[Mapping]

Nobody-User = nobody
Nobody-Group = nobody
'''

	node.sendfile(remotefile = "/etc/idmapd.conf", data = idmapd_conf)

##################################################################
# Update the exports file on the given node
##################################################################
def nfs_write_exports(server, exports):

	if not server.sendfile(remotefile = "/etc/exports", data = bytearray(exports)):
		journal.failure("unable to upload exports file")
		return False

	if not nfs_run(server, "/etc/init.d/nfsserver reload"):
		return False

	journal.info("downloading exports file for comparison")
	status = server.recvfile("/etc/exports")
	if not status:
		journal.failure("unable to download exports file");
		return False

	journal.info("Content of exports file")
	journal.recordBuffer(status.buffer)
	return True


def nfs_write_verify_exports(server, exports):
	global client1

	journal.beginTest(None, "updating exports file on %s" % server.name)
	if nfs_write_exports(server, exports):
		journal.info("verifying visibility on the client side")
		nfs_run(client1, "/usr/sbin/showmount -e %s" % server.ipaddr)

##################################################################
# Initialize server and clients
##################################################################
def nfs_init_all():
	global client1, client2, server

	if not server:
		setup()
		init_server(server);
		init_client(client1);
		if client2:
			init_client(client2);


##################################################################
# Mount and unmount a directory
##################################################################
def __nfs_do_mount(client, servername, clientdir, serverdir, options = None):
	journal.info("mounting %s from %s (options %s)" % (serverdir, servername, options))
	if options:
		cmdline = "/bin/mount %s:%s %s -o %s" % (servername, serverdir, clientdir, options)
	else:
		cmdline = "/bin/mount %s:%s %s" % (servername, serverdir, clientdir)

	return __nfs_run(client, cmdline)

def __nfs_do_umount(client, clientdir):
	rv = __nfs_run(client, "/bin/umount " + clientdir)
	if not rv and __nfs_is_mounted(client, clientdir):
		import time

		# Note, if the original umount call failed, we will always
		# return that failure status, even if we manage to unmount
		# the directory at a later point
		journal.warning("it seems we failed to unmount %s - maybe still busy" % clientdir)

		journal.info("Trying to kill off all processes accessing the directory")
		client.run("fuser -km " + clientdir)

		retry = 5
		while __nfs_is_mounted(client, clientdir) and retry > 0:
			journal.info("Sleeping for 10 seconds...")
			time.sleep(10)
			journal.info("Retrying unmount call")
			__nfs_run(client, "/bin/umount " + clientdir)
			retry -= 1

		if retry < 0:
			journal.info("Giving up")

def __nfs_is_mounted(node, dir):
	mtab = __nfs_mtab_get(node)
	if not mtab:
		return False

	return __nfs_mtab_find_mountpoint(mtab, dir)

def __nfs_mtab_get(node):
	# It would be nice to read the proc file directly, but unfortunately,
	# sshd doesn't handle /proc files correctly.
	journal.info("obtaining /proc/mounts from node " + node.name)
	st = node.run("cat /proc/mounts", suppressOutput = True)
	if not st:
		journal.failure("unable to extract /proc/mounts")
		return None
	
	return str(st.stdout)

def __nfs_mtab_find_mountpoint(mtab, dir):
	for l in mtab.split('\n'):
		l = l.split(' ')
		if len(l) > 1 and l[1] == dir:
			return True
	return False

##################################################################
# Mount and unmount a "standard" directory, ie mount
# /srv/nfs/dirX to /mnt/dirX on the client
##################################################################
def __nfs_server_file(dir, relativeName = None):
	path = "/srv/nfs/" + dir
	if relativeName:
		path += "/" + relativeName
	return path

def __nfs_client_file(dir, relativeName = None):
	path = "/mnt/" + dir
	if relativeName:
		path += "/" + relativeName
	return path

def nfs_do_mount(client, servername, dir, options = None):
	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)

	return __nfs_do_mount(client, servername, clientdir, serverdir, options)

def nfs_do_umount(client, dir):
	return __nfs_do_umount(client, __nfs_client_file(dir))

def __nfs_verify_mount(client, servername, dir):
	if not nfs_do_mount(client, servername, dir):
		return False
	return nfs_do_umount(client, dir);

def __nfs_mount_should_succeed(client, servername, dir, options = None):
	if options:
		journal.beginTest(None, "mount with options %s" % options)
	else:
		journal.beginTest(None, "mount without options")

	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)
	if __nfs_do_mount(client, servername, clientdir, serverdir, options):
		if __nfs_is_mounted(client, clientdir):
			journal.success()
			return True
		journal.failure("Directory was not mounted (which is bad), but mount(8) reported success (which is even worse)")
	elif __nfs_is_mounted(client, clientdir):
		journal.failure("Directory was mounted (which is good), but mount(8) reported an error")
	else:
		journal.failure("This mount attempt should have succeeded")
	return False

def nfs_mount_should_succeed(client, servername, dir, options = None):
	rv = __nfs_mount_should_succeed(client, servername, dir, options);
	nfs_do_umount(client, dir)
	return rv

def __nfs_mount_should_fail(client, servername, dir, options = None):
	if options:
		journal.beginTest(None, "mount with options %s" % options)
	else:
		journal.beginTest(None, "mount without options")

	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)
	if not __nfs_do_mount(client, servername, clientdir, serverdir, options):
		if not __nfs_is_mounted(client, clientdir):
			journal.success()
			return True
		journal.failure("Directory was mounted (which is good) even though mount(8) reported an error")
	elif not __nfs_is_mounted(client, clientdir):
		journal.failure("Directory was not mounted (which is good), but mount(8) reported success")
	else:
		journal.failure("This mount attempt should have failed")
	return False

def nfs_mount_should_fail(client, servername, dir, options = None):
	rv = __nfs_mount_should_fail(client, servername, dir, options);
	nfs_do_umount(client, dir)
	return rv

##################################################################
# Create a file on a read-only volume
##################################################################
def __nfs_verify_readonly(client, filename, timeout = -1):

	import time

	t0 = time.time();

	if __nfs_run(client, "/bin/touch " + filename, timeout = timeout):
		journal.failure("file system should be read-only, but succeeded in creating file")
		return False

	delay = time.time() - t0

	# We check how long this took, because a misconfigured/broken NFSv4 idmapping
	# may cause significant delays on the first access.
	if delay > 5:
		journal.failure("Creating the file took too long (%u seconds)" % delay)
		return False
	
	return True

def nfs_verify_readonly(dir, options):
	global client1, server

	nfs_run(server, "/bin/rm -f " + __nfs_server_file(dir, "readonly-test"))

	if not nfs_do_mount(client1, server.ipaddr, dir, options):
		return False

	rv = __nfs_verify_readonly(client1, __nfs_client_file(dir, "readonly-test"))
	nfs_do_umount(client1, dir)
	return rv

##################################################################
# On the very first file operation after a reboot, the server
# make take very long to respond to the request.
# Try to deal with this gracefully, but still flag this as a
# problem.
##################################################################
def nfs_verify_readonly_slow(dir):
	global client1, server

	nfs_run(server, "/bin/rm -f " + __nfs_server_file(dir, "readonly-test"))

	# TCP mount, retry operation after 20 seconds, retry twice.
	# This operation should time out after less than 60 seconds overall
	if not nfs_do_mount(client1, server.ipaddr, dir, "tcp,soft,intr,timeo=200,retrans=2"):
		return False

	rv = __nfs_verify_readonly(client1, __nfs_client_file(dir, "readonly-test"), 4 * 60)
	nfs_do_umount(client1, dir)
	return rv

##################################################################
# Create a file on a read-write volume
##################################################################
def __nfs_verify_readwrite(client, filename, verifyuid, verifygid):

	global server
	import time

	t0 = time.time();

	if not __nfs_run(client, "/bin/touch " + filename):
		journal.failure("file system should be read-write, but failed in creating file")
		return False

	delay = time.time() - t0

	if verifyuid >= 0:
		st = client.run("/bin/stat -c %u " + filename, suppressOutput = True)
		if not st:
			journal.failure("Unable to stat created file")
			return False

		try:
			uid = int(st.stdout)
		except:
			uid = -1
		if uid != verifyuid:
			journal.failure("file should have been created with uid %u but has uid %u" % (verifyuid, uid))
			return False

	# FIXME: verify gid

	# We check how long this took, because a misconfigured/broken NFSv4 idmapping
	# may cause significant delays on the first access.
	if delay > 5:
		journal.failure("Creating the file took too long (%u seconds)" % delay)
		return False


def nfs_verify_readwrite(dir, options, verifyuid = -1, verifygid = -1):
	global client1, server

	nfs_run(server, "/bin/rm -f " + __nfs_server_file(dir, "readwrite-test"))

	if not nfs_do_mount(client1, server.ipaddr, dir, options):
		return False

	rv = __nfs_verify_readwrite(client1, __nfs_client_file(dir, "readwrite-test"), verifyuid, verifygid)
	nfs_do_umount(client1, dir)
	return rv

##################################################################
# Verify that export matching works properly
##################################################################
def nfs_verify_exports_matching(testName, client, clientName):

	exports_data = '''
/srv/nfs/dir1   *(ro,no_subtree_check)
/srv/nfs/dir1   %s(rw,no_root_squash,no_subtree_check)
'''

	journal.beginTest(testName, "export read-write to " + clientName)
	nfs_write_exports(server, exports_data % clientName)
	nfs_verify_readwrite("dir1", None, 0, 0);

	# And now the other way around
	exports_data = '''
/srv/nfs/dir1   %s(ro,no_subtree_check) *(rw,no_root_squash,no_subtree_check)
'''

	journal.beginTest(testName + "-rev", "export read-only to " + clientName)
	nfs_write_exports(server, exports_data % clientName)
	nfs_verify_readonly("dir1", None)

def __nfs_ipv4_prefix(ipaddr, pfxlen):
	if pfxlen == 8:
		ipnetwork = ipaddr.rsplit('.', 3)[0]
		ipnetwork += ".0.0.0/8";
	elif pfxlen == 16:
		ipnetwork = ipaddr.rsplit('.', 2)[0]
		ipnetwork += ".0.0/16";
	elif pfxlen == 24:
		ipnetwork = ipaddr.rsplit('.', 1)[0]
		ipnetwork += ".0/24";
	elif pfxlen == 32:
		ipnetwork = ipaddr + "/32";
	
	return ipnetwork

def __nfs_ipv4_netmask(ipaddr, pfxlen):
	if pfxlen == 8:
		ipnetwork = ipaddr.rsplit('.', 3)[0]
		ipnetwork += ".0.0.0/255.0.0.0";
	elif pfxlen == 16:
		ipnetwork = ipaddr.rsplit('.', 2)[0]
		ipnetwork += ".0.0/255.255.0.0";
	elif pfxlen == 24:
		ipnetwork = ipaddr.rsplit('.', 1)[0]
		ipnetwork += ".0/255.255.255.0";
	elif pfxlen == 32:
		ipnetwork = ipaddr + "/255.255.255.255";
	
	return ipnetwork

##################################################################
# These functions test various peculiarities of the NFS
# file system
##################################################################
def nfstool_run(client, args):
	return nfs_run(client, nfstool + " " + args)

def __nfstool_run(client, args):
	return __nfs_run(client, nfstool + " " + args)

def nfs_test_createfile(client, dir):

	tf = dir + "/testfile";

	# Open a file with O_CREAT.
	journal.beginTest(None, "create file");
	if nfstool_run(client1, "create-file " + tf):
		__nfs_run(client1, "/bin/rm -f " + tf)
		journal.success()

	# Open a file with O_CREAT|O_EXCL, twice.
	journal.beginTest(None, "Create file with O_EXCL, twice");
	journal.info("the first call should succeed, the second one should fail")
	if not __nfstool_run(client1, "create-file -x " + tf):
		journal.failure("First file open with O_EXCL failed (should have succeeded)")
	elif __nfstool_run(client1, "create-file -x " + tf):
		journal.failure("Second file open with O_EXCL succeeded (should have failed)")

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_writefile(client, dir):

	tf = dir + "/testfile";

	journal.beginTest(None, "write to file")
	if not __nfs_run(client, "/bin/dd if=/dev/zero of=%s bs=1k count=4k" % tf):
		journal.failure("Failed to write to file")

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_chown(client, dir):

	tf = dir + "/testfile"

	journal.beginTest(None, "change file's ownership")
	if nfs_run(client, "touch " + tf):
		nfs_run(client, "/bin/chown --changes nobody " + tf)

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_chmod(client, dir):

	tf = dir + "/testfile"

	journal.beginTest(None, "change file's permissions")
	if nfs_run(client, "touch " + tf):
		nfs_run(client, "/bin/chmod --changes 0600 " + tf)

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_silly_rename(client, dir):

	src = dir + "/testfile1"
	dst = dir + "/testfile2"

	journal.beginTest(None, "Verify silly-rename semantics")
	journal.info("Open dst, rename src to dst, verify both files")
	nfstool_run(client, "silly-rename %s %s" % (src, dst))
	nfs_run(client1, "/bin/rm -f " + src)
	nfs_run(client1, "/bin/rm -f " + dst)

	journal.beginTest(None, "Verify silly-rename semantics #2")
	journal.info("Open dst, rename src to dst, verify both files. Leave src open the whole time")
	nfstool_run(client, "silly-rename -x %s %s" % (src, dst))
	nfs_run(client1, "/bin/rm -f " + src)
	nfs_run(client1, "/bin/rm -f " + dst)

def nfs_test_silly_unlink(client, dir):

	tf = dir + "/testfile"

	journal.beginTest(None, "Verify silly-unlink semantics")
	journal.info("Open testfile, unlink it, verify content")
	nfstool_run(client, "silly-unlink " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_socket(client, dir):

	tf = dir + "/mysock"

	journal.beginTest(None, "Verify socket creation")
	nfstool_run(client, "create-special -t socket -m 0644 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_fifo(client, dir):

	tf = dir + "/myfifo"

	journal.beginTest(None, "Verify FIFO creation")
	nfstool_run(client, "create-special -t fifo -m 0644 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_chrdev(client, dir):

	tf = dir + "/devnull"

	journal.beginTest(None, "Verify chardev creation")
	nfstool_run(client, "create-special -t chrdev -m 0644 -d 1:3 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_blkdev(client, dir):

	tf = dir + "/devloop"

	journal.beginTest(None, "Verify blockdev creation")
	nfstool_run(client, "create-special -t blkdev -m 0600 -d 7:0 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_symlink(client, dir):

	link = dir + "/imasymlink"
	target = dir + "/testfile"
	basename = "testfile"

	journal.beginTest(None, "Verify symlink operation")
	if not client.sendfile(target, data = bytearray("imadoofus")):
		journal.failure("unable to write target file")
		return False

	if nfs_run(client, "/bin/ln -s %s %s" % (basename, link)):
		st = client.recvfile(link)
		if not st or str(st.buffer) != "imadoofus":
			journal.failure("problem verifying file content through symlink")

	journal.beginTest(None, "Verify symlink operation #2")
	if __nfs_run(client, "/bin/ln -s randomlink %s" % link):
		journal.failure("/bin/ln -s on an existing symlink did not fail")

	nfs_run(client1, "/bin/rm -f " + link)
	nfs_run(client1, "/bin/rm -f " + target)

	# TBD: verify behavior of symlinks pointing outside the exported directory

def nfs_test_hardlink(client, dir):

	link = dir + "/imahardlink"
	target = dir + "/testfile"
	basename = "testfile"

	journal.beginTest(None, "Verify hardlink operation")
	if not client.sendfile(target, data = bytearray("imadoofus")):
		journal.failure("unable to write target file")
		return False

	if nfs_run(client, "/bin/ln %s %s" % (target, link)):
		st = client.recvfile(link)
		if not st or str(st.buffer) != "imadoofus":
			journal.failure("problem verifying file content through hardlink")

	journal.beginTest(None, "Verify hardlink operation #2")
	if __nfs_run(client, "/bin/ln %s %s" % (target, link)):
		journal.failure("/bin/ln on an existing hardlink did not fail")

	nfs_run(client1, "/bin/rm -f " + link)
	nfs_run(client1, "/bin/rm -f " + target)


##################################################################
# General NFS mount testing
##################################################################
def nfs_test_mount():
	global client1, client2, server

	journal.beginGroup("mount")

	exports_data = '''
/srv/nfs/dir1   *(ro,no_subtree_check)
/srv/nfs/dir2   *(rw,no_root_squash,no_subtree_check)
/srv/nfs/dir3   *(rw,no_subtree_check)
'''

	nfs_write_verify_exports(server, exports_data)

	journal.beginTest(None, "verify that we can mount from server by name")
	__nfs_verify_mount(client1, "nfs-server", "dir1");

	nfs_mount_should_succeed(client1, server.ipaddr, "dir1")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir3")
	nfs_mount_should_fail(client1,    server.ipaddr, "dir4")

	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "vers=2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "vers=3")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=4")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,nolock")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,nolock")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,udp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,udp")

	# TBD: Mounting /srv/nfs/dir1/../../../etc should fail


def nfs_test_exports():

	global client1, client2, server

	journal.beginGroup("exports")

	exports_data = '''
/srv/nfs/dir1	*(ro,subtree_check)
/srv/nfs/dir2	*(rw,no_root_squash,subtree_check)
/srv/nfs/dir3	*(rw,subtree_check)
/srv/nfs/dir4	*(rw,root_squash,anonuid=60000,subtree_check)
'''

	nfs_write_verify_exports(server, exports_data)
	nfs_verify_readonly_slow("dir1")

	for options in [None, "vers=2", "vers=3", "vers=4"]:
		journal.beginTest(None, "verify that dir1 is exported read-only")
		nfs_verify_readonly("dir1", options);

		journal.beginTest(None, "verify that dir2 is exported read-write")
		nfs_verify_readwrite("dir2", options, 0, 0);

		journal.beginTest(None, "verify that dir3 is exported read-write with root squash")
		nfs_verify_readwrite("dir3", options, 65534, 65534);

		journal.beginTest(None, "verify that dir4 is exported read-write with anonuid=60000")
		nfs_verify_readwrite("dir4", options, 60000, 65534);

	##################################################################
	# Test IP prefix matching
	##################################################################
	nfs_verify_exports_matching("match-ipaddr", client1, client1.ipaddr)
	nfs_verify_exports_matching("match-ip-prefix8", client1, __nfs_ipv4_prefix(client1.ipaddr, 8))
	nfs_verify_exports_matching("match-ip-prefix16", client1, __nfs_ipv4_prefix(client1.ipaddr, 16))
	nfs_verify_exports_matching("match-ip-prefix24", client1, __nfs_ipv4_prefix(client1.ipaddr, 24))
	nfs_verify_exports_matching("match-ip-prefix32", client1, __nfs_ipv4_prefix(client1.ipaddr, 32))
	nfs_verify_exports_matching("match-ip-netmask8", client1, __nfs_ipv4_netmask(client1.ipaddr, 8))
	nfs_verify_exports_matching("match-ip-netmask16", client1, __nfs_ipv4_netmask(client1.ipaddr, 16))
	nfs_verify_exports_matching("match-ip-netmask24", client1, __nfs_ipv4_netmask(client1.ipaddr, 24))
	nfs_verify_exports_matching("match-ip-netmask32", client1, __nfs_ipv4_netmask(client1.ipaddr, 32))

	##################################################################
	# Test hostname matching
	##################################################################
	nfs_verify_exports_matching("match-fqdn", client1, "client1.testing.opensuse.org")
	nfs_verify_exports_matching("match-domain", client1, "*.testing.opensuse.org")


def nfs_test_fileops():

	global client1, client2, server

	journal.beginGroup("fileops")

	exports_data = '''
/srv/nfs/dir1	*(rw,no_root_squash,subtree_check)
'''
	nfs_write_verify_exports(server, exports_data)

	for options in [None, "vers=2", "vers=3", "vers=4"]:
		journal.beginTest(None, "Mounting dir with options %s" % options)
		if not nfs_do_mount(client1, server.ipaddr, "dir1", options):
			journal.info("Skipping fileops tests for these options - cannot mount directory");
			continue;

		clientdir = __nfs_client_file("dir1")
		nfs_test_createfile(client1, clientdir)
		nfs_test_writefile(client1, clientdir)
		nfs_test_chown(client1, clientdir)
		nfs_test_chmod(client1, clientdir)
		nfs_test_silly_rename(client1, clientdir)
		nfs_test_silly_unlink(client1, clientdir)
		nfs_test_socket(client1, clientdir)
		nfs_test_fifo(client1, clientdir)
		nfs_test_chrdev(client1, clientdir)
		nfs_test_blkdev(client1, clientdir)
		nfs_test_symlink(client1, clientdir)
		nfs_test_hardlink(client1, clientdir)

		nfs_do_umount(client1, "dir1")

def main():
	nfs_init_all()
	nfs_test_mount()
	nfs_test_exports()
	nfs_test_fileops()

	journal.writeReport()

main()
