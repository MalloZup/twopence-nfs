#!/usr/bin/python
#
# Test program to verify that NFS client and server function properly
#
# Copyright (C) 2015 Olaf Kirch <okir@suse.de>
#

import sys
import suselog
import twopence
import susetest
import time

journal = None
server = None
client1 = None
client2 = None

nfstool	= "/usr/bin/nfs"

def setup():
	global client1, client2, server, journal

	config = susetest.Config()
	reportPath = config.value("report")
	if not reportPath:
		reportPath = "report.xml"
	journal = suselog.Journal("nfs", path = reportPath);

	journal.beginGroup("setup")

	server = config.target("server")
	client1 = config.target("client1")

	try:
		client2 = config.target("client2")
	except:
		journal.info("No second client defined, skipping all two-client test cases")

	if not client1.ipaddr:
		journal.fatal("No IP address set for client1");
	if client2 and not client2.ipaddr:
		journal.fatal("No IP address set for client2");
	if not server.ipaddr:
		journal.fatal("No IP address set for server");

	# FIXME: we should also verify the host names of these nodes

def __nfs_log_status(status):
	if not status:
		journal.info("command failed: " + status.message)

	journal.recordStdout(status.stdout);
	if status.stdout != status.stderr:
		journal.recordStderr(status.stderr);

def __nfs_cmd_set_timeout(cmd, timeout):
	# Ugly, but needed until upstream twopence is fixed
	try:
		cmd.timeout = timeout;
	except:
		timeout = str(timeout);
	try:
		cmd.timeout = timeout;
	except:
		journal.warning("Unable to set command timeout; expect issues")

def __nfs_run(target, command, timeout = -1):
	cmd = twopence.Command(command)
	if timeout >= 0:
		__nfs_cmd_set_timeout(cmd, timeout)

	journal.info(target.name + ": " + cmd.commandline)
	try:
		status = target.run(cmd)
	except:
		journal.failure("command execution failed with exception")
		status = twopence.Status(256, bytearray(), bytearray())

	__nfs_log_status(status)
	return status

def log_buffered_output(desc, data):
	# data is usually a bytearray
	if len(data) == 0:
		return

	journal.failure(desc + ":")
	for line in str(data).split("\n"):
		journal.failure(line);

def nfs_run(target, command):
	status = __nfs_run(target, command)
	if not(status):
		journal.failure("command \"" + command + "\" failed: " + status.message);
	return status

def nfs_run_background(node, command, timeout = -1):
	cmd = twopence.Command(command, background = 1)
	if timeout >= 0:
		__nfs_cmd_set_timeout(cmd, timeout)

	journal.info(node.name + ": " + cmd.commandline + " (backgrounded)")
	try:
		node.run(cmd)
		return True
	except:
		journal.failure("command execution failed with exception")
		return False

def nfs_wait(node, command = None):
	if command:
		status = node.wait(command)
	else:
		status = node.wait()

	if status == None:
		return False

	journal.info("Backgrounded command finished: " + status.command.commandline)
	__nfs_log_status(status)
	return status

##################################################################
# Add a line to a hosts file
##################################################################
def nfs_add_hostsfile(node, addr, fqdn):
	alias = fqdn.split('.')[0]
	if alias != fqdn:
		line = "%s %s %s" % (addr, fqdn, alias)
	else:
		line = "%s %s" % (addr, fqdn)

	journal.beginTest(None, "update hosts file on %s" % node.name)
	status = node.recvfile("/etc/hosts");
	if not status:
		journal.failure("unable to download hosts file");
		return False;

	for l in str(status.buffer).split('\n'):
		if l == line:
			journal.info("requested line already in hosts file, nothing to be done")
			journal.success()
			return True

	buffer = status.buffer + "\n" + line + "\n"
	if not node.sendfile("/etc/hosts", data = buffer):
		journal.failure("unable to upload modified hosts file");
		return False

	journal.success();
	return True

##################################################################
# Set a sysconfig variable
# We should really have a suseutils module and add such stuff
# there.
##################################################################
def nfs_sysconfig_set(node, var, value):

	command = "sed -i 's:^[# ]*%s=.*:%s=\"%s\":' /etc/sysconfig/nfs" % (var, var, value)
	nfs_run(node, command)
	nfs_run(node, "grep %s /etc/sysconfig/nfs" % var)

##################################################################
# Initialize RPC tests and run some initial sanity checks
##################################################################
def init_server(node):
	global client1, client2;

	journal.beginGroup("server-init", "enable NFS server")

	nfs_init_common(node)

	journal.beginTest(None, "enable nfsd and rpcbind on server")
	nfs_run(node, "/bin/rm -rf /srv/nfs/dir{1,2,3,4}")
	nfs_run(node, "/bin/mkdir -p -m 777 /srv/nfs/dir{1,2,3,4}")


	if node.run("test -x /usr/bin/systemctl"):
		use_systemd = True
		nfs_run(node, "/etc/init.d/nfsserver start")
		nfs_run(node, "/usr/bin/systemctl enable nfsserver");
	else:
		nfs_run(node, "insserv -d nfsserver");
		nfs_run(node, "/etc/init.d/nfsserver start")


	# Help: add the two clients to the server's hosts file
	nfs_add_hostsfile(node, client1.ipaddr, "client1.testing.opensuse.org")

	if client2:
		nfs_add_hostsfile(node, client2.ipaddr, "client2.testing.opensuse.org")

	journal.beginTest(None, "Check whether NFSv2 is enabled by default")
	status = nfs_run(node, "cat /proc/fs/nfsd/versions")
	if status and status.stdout.find("-2") >= 0:
		journal.info("NFSv2 disabled on server by default");

		journal.beginTest(None, "Enabling NFSv2 on server")
		nfs_sysconfig_set(node, "MOUNTD_OPTIONS", "-V2")
		nfs_sysconfig_set(node, "NFSD_OPTIONS", "-V2")
		nfs_run(node, "rcnfsserver restart")

	journal.finishGroup()

##################################################################
# Initialize an NFS client node
##################################################################
def init_client(node):
	global server;

	journal.beginTest(None, "initialize client %s" % node.name)

	nfs_init_common(node)

	nfs_add_hostsfile(node, server.ipaddr, "nfs-server.testing.opensuse.org")
	if not __nfs_run(node, "/usr/sbin/showmount -e nfs-server.testing.opensuse.org"):
		journal.fatal("Unable to contact NFS server")
		return False

	mtab = __nfs_mtab_get(node)
	for dir in ["dir1", "dir2", "dir3", "dir4"]:
		clientdir = __nfs_client_file(dir);
		if __nfs_mtab_find_mountpoint(mtab, clientdir):
			journal.info("Unmounting dir left mounted from previous test run")
			nfs_do_umount(node, dir);

		if not __nfs_run(node, "test -d %s || mkdir -p %s" % (clientdir, clientdir)):
			journal.fatal( "Failed to set up NFS mount points")
			return False

	# nfs_write_idmap_conf(node)

	# A simple start is not enough to make it start all helper services
	if not __nfs_run(node, "/etc/init.d/nfs force-start"):
		journal.fatal("NFS start script exited with error")
		return False;

	# In current kernels, the default is to not perform ID mapping
	# in NFSv4 unless auth flavors other than AUTH_SYS are used.
	# Since we want to use it, enable it.
	# node.sendfile(remotefile = "/sys/module/nfs/parameters/nfs4_disable_idmapping", data = "N")

	return True

##################################################################
# Common initialization code for clients and server
##################################################################
def nfs_init_common(node):
	if node.run("test -x /usr/bin/systemctl"):
		nfs_run(node, "/usr/bin/systemctl enable rpcbind.socket")
		nfs_run(node, "/usr/bin/systemctl start rpcbind.socket")
	else:
		nfs_run(node, "insserv -d rpcbind")
		nfs_run(node, "/etc/init.d/rpcbind start")

	# exercise your shift key, stop the firewall
	nfs_run(node, "rcSuSEfirewall2 stop")


##################################################################
# Update the idmapd.conf file on the given node
##################################################################
def nfs_write_idmap_conf(node):

	idmapd_conf = '''
[General]

Verbosity = 15
Pipefs-Directory = /var/lib/nfs/rpc_pipefs
Domain = testing.opensuse.org

[Mapping]

Nobody-User = nobody
Nobody-Group = nobody
'''

	node.sendfile(remotefile = "/etc/idmapd.conf", data = idmapd_conf)

##################################################################
# Update the exports file on the given node
##################################################################
def nfs_write_exports(server, exports):

	if not server.sendfile(remotefile = "/etc/exports", data = bytearray(exports)):
		journal.failure("unable to upload exports file")
		return False

	if not nfs_run(server, "/etc/init.d/nfsserver reload"):
		return False

	journal.info("downloading exports file for comparison")
	status = server.recvfile("/etc/exports")
	if not status:
		journal.failure("unable to download exports file");
		return False

	journal.info("Content of exports file")
	journal.recordBuffer(status.buffer)
	return True


def nfs_write_verify_exports(server, exports):
	global client1

	journal.beginTest(None, "updating exports file on %s" % server.name)
	if nfs_write_exports(server, exports):
		journal.info("verifying visibility on the client side")
		nfs_run(client1, "/usr/sbin/showmount -e %s" % server.ipaddr)

##################################################################
# Initialize server and clients
##################################################################
def nfs_init_all():
	global client1, client2, server

	if not server:
		setup()
		init_server(server);

		journal.beginGroup("client-init", "initialize clients")
		init_client(client1);
		if client2:
			init_client(client2);


##################################################################
# Mount and unmount a directory
##################################################################
def nfs_join_mount_options(left, right):
	if left and right:
		return left + "," + right
	if left:
		return left
	return right

def __nfs_do_mount(client, servername, clientdir, serverdir, options = None):
	journal.info("mounting %s from %s (options %s)" % (serverdir, servername, options))
	if options:
		cmdline = "/bin/mount %s:%s %s -o %s" % (servername, serverdir, clientdir, options)
	else:
		cmdline = "/bin/mount %s:%s %s" % (servername, serverdir, clientdir)

	return __nfs_run(client, cmdline)

def __nfs_do_umount(client, clientdir):
	rv = __nfs_run(client, "/bin/umount " + clientdir)
	if not rv and __nfs_is_mounted(client, clientdir):
		import time

		# Note, if the original umount call failed, we will always
		# return that failure status, even if we manage to unmount
		# the directory at a later point
		journal.warning("it seems we failed to unmount %s - maybe still busy" % clientdir)

		journal.info("Trying to kill off all processes accessing the directory")
		client.run("fuser -km " + clientdir)

		retry = 5
		while __nfs_is_mounted(client, clientdir) and retry > 0:
			journal.info("Sleeping for 10 seconds...")
			time.sleep(10)
			journal.info("Retrying unmount call")
			__nfs_run(client, "/bin/umount " + clientdir)
			retry -= 1

		if retry < 0:
			journal.info("Giving up")

def __nfs_is_mounted(node, dir):
	mtab = __nfs_mtab_get(node)
	if not mtab:
		return False

	return __nfs_mtab_find_mountpoint(mtab, dir)

def __nfs_mtab_get(node):
	# It would be nice to read the proc file directly, but unfortunately,
	# sshd doesn't handle /proc files correctly.
	journal.info("obtaining /proc/mounts from node " + node.name)
	st = node.run("cat /proc/mounts", suppressOutput = True)
	if not st:
		journal.failure("unable to extract /proc/mounts")
		return None
	
	return str(st.stdout)

def __nfs_mtab_find_mountpoint(mtab, dir):
	for l in mtab.split('\n'):
		l = l.split(' ')
		if len(l) > 1 and l[1] == dir:
			return True
	return False

##################################################################
# Mount and unmount a "standard" directory, ie mount
# /srv/nfs/dirX to /mnt/dirX on the client
##################################################################
def __nfs_server_file(dir, relativeName = None):
	path = "/srv/nfs/" + dir
	if relativeName:
		path += "/" + relativeName
	return path

def __nfs_client_file(dir, relativeName = None):
	path = "/mnt/" + dir
	if relativeName:
		path += "/" + relativeName
	return path

def nfs_do_mount(client, servername, dir, options = None):
	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)

	return __nfs_do_mount(client, servername, clientdir, serverdir, options)

def nfs_do_umount(client, dir):
	return __nfs_do_umount(client, __nfs_client_file(dir))

def __nfs_verify_mount(client, servername, dir):
	if not nfs_do_mount(client, servername, dir):
		return False
	return nfs_do_umount(client, dir);

def __nfs_mount_should_succeed(client, servername, dir, options = None):
	if options:
		journal.beginTest(None, "mount with options %s" % options)
	else:
		journal.beginTest(None, "mount without options")

	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)
	if __nfs_do_mount(client, servername, clientdir, serverdir, options):
		if __nfs_is_mounted(client, clientdir):
			journal.success()
			return True
		journal.failure("Directory was not mounted (which is bad), but mount(8) reported success (which is even worse)")
	elif __nfs_is_mounted(client, clientdir):
		journal.failure("Directory was mounted (which is good), but mount(8) reported an error")
	else:
		journal.failure("This mount attempt should have succeeded")
	return False

def nfs_mount_should_succeed(client, servername, dir, options = None):
	rv = __nfs_mount_should_succeed(client, servername, dir, options);
	nfs_do_umount(client, dir)
	return rv

def __nfs_mount_should_fail(client, servername, dir, options = None):
	if options:
		journal.beginTest(None, "mount with options %s" % options)
	else:
		journal.beginTest(None, "mount without options")

	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)
	if not __nfs_do_mount(client, servername, clientdir, serverdir, options):
		if not __nfs_is_mounted(client, clientdir):
			journal.success()
			return True
		journal.failure("Directory was mounted (which is good) even though mount(8) reported an error")
	elif not __nfs_is_mounted(client, clientdir):
		journal.failure("Directory was not mounted (which is good), but mount(8) reported success")
	else:
		journal.failure("This mount attempt should have failed")
	return False

def nfs_mount_should_fail(client, servername, dir, options = None):
	rv = __nfs_mount_should_fail(client, servername, dir, options);
	nfs_do_umount(client, dir)
	return rv

##################################################################
# Create a file on a read-only volume
##################################################################
def __nfs_verify_readonly(client, filename, timeout = -1):

	import time

	t0 = time.time();

	if __nfs_run(client, "/bin/touch " + filename, timeout = timeout):
		journal.failure("file system should be read-only, but succeeded in creating file")
		return False

	delay = time.time() - t0

	# We check how long this took, because a misconfigured/broken NFSv4 idmapping
	# may cause significant delays on the first access.
	if delay > 5:
		journal.failure("Creating the file took too long (%u seconds)" % delay)
		return False
	
	return True

def nfs_verify_readonly(dir, options):
	global client1, server

	nfs_run(server, "/bin/rm -f " + __nfs_server_file(dir, "readonly-test"))

	if not nfs_do_mount(client1, server.ipaddr, dir, options):
		return False

	rv = __nfs_verify_readonly(client1, __nfs_client_file(dir, "readonly-test"))
	nfs_do_umount(client1, dir)
	return rv

##################################################################
# On the very first file operation after a reboot, the server
# make take very long to respond to the request.
# Try to deal with this gracefully, but still flag this as a
# problem.
##################################################################
def nfs_verify_readonly_slow(dir):
	global client1, server

	nfs_run(server, "/bin/rm -f " + __nfs_server_file(dir, "readonly-test"))

	# TCP mount, retry operation after 20 seconds, retry twice.
	# This operation should time out after less than 60 seconds overall
	if not nfs_do_mount(client1, server.ipaddr, dir, "tcp,soft,intr,timeo=200,retrans=2"):
		return False

	rv = __nfs_verify_readonly(client1, __nfs_client_file(dir, "readonly-test"), 4 * 60)
	nfs_do_umount(client1, dir)
	return rv

##################################################################
# Create a file on a read-write volume
##################################################################
def __nfs_verify_readwrite(client, filename, verifyuid, verifygid):

	global server
	import time

	t0 = time.time();

	if not __nfs_run(client, "/bin/touch " + filename):
		journal.failure("file system should be read-write, but failed in creating file")
		return False

	delay = time.time() - t0

	if verifyuid >= 0:
		st = client.run("/bin/stat -c %u " + filename, suppressOutput = True)
		if not st:
			journal.failure("Unable to stat created file")
			return False

		try:
			uid = int(st.stdout)
		except:
			uid = -1
		if uid != verifyuid:
			journal.failure("file should have been created with uid %u but has uid %u" % (verifyuid, uid))
			return False

	# FIXME: verify gid

	# We check how long this took, because a misconfigured/broken NFSv4 idmapping
	# may cause significant delays on the first access.
	if delay > 5:
		journal.failure("Creating the file took too long (%u seconds)" % delay)
		return False


def nfs_verify_readwrite(dir, options, verifyuid = -1, verifygid = -1):
	global client1, server

	nfs_run(server, "/bin/rm -f " + __nfs_server_file(dir, "readwrite-test"))

	if not nfs_do_mount(client1, server.ipaddr, dir, options):
		return False

	rv = __nfs_verify_readwrite(client1, __nfs_client_file(dir, "readwrite-test"), verifyuid, verifygid)
	nfs_do_umount(client1, dir)
	return rv

##################################################################
# Verify that export matching works properly
##################################################################
def nfs_verify_exports_matching(testName, client, clientName):

	exports_data = '''
/srv/nfs/dir1   *(ro,no_subtree_check)
/srv/nfs/dir1   %s(rw,no_root_squash,no_subtree_check)
'''

	journal.beginTest(testName, "export read-write to " + clientName)
	nfs_write_exports(server, exports_data % clientName)
	nfs_verify_readwrite("dir1", None, 0, 0);

	# And now the other way around
	exports_data = '''
/srv/nfs/dir1   %s(ro,no_subtree_check) *(rw,no_root_squash,no_subtree_check)
'''

	journal.beginTest(testName + "-rev", "export read-only to " + clientName)
	nfs_write_exports(server, exports_data % clientName)
	nfs_verify_readonly("dir1", None)

def __nfs_ipv4_prefix(ipaddr, pfxlen):
	if pfxlen == 8:
		ipnetwork = ipaddr.rsplit('.', 3)[0]
		ipnetwork += ".0.0.0/8";
	elif pfxlen == 16:
		ipnetwork = ipaddr.rsplit('.', 2)[0]
		ipnetwork += ".0.0/16";
	elif pfxlen == 24:
		ipnetwork = ipaddr.rsplit('.', 1)[0]
		ipnetwork += ".0/24";
	elif pfxlen == 32:
		ipnetwork = ipaddr + "/32";
	
	return ipnetwork

def __nfs_ipv4_netmask(ipaddr, pfxlen):
	if pfxlen == 8:
		ipnetwork = ipaddr.rsplit('.', 3)[0]
		ipnetwork += ".0.0.0/255.0.0.0";
	elif pfxlen == 16:
		ipnetwork = ipaddr.rsplit('.', 2)[0]
		ipnetwork += ".0.0/255.255.0.0";
	elif pfxlen == 24:
		ipnetwork = ipaddr.rsplit('.', 1)[0]
		ipnetwork += ".0/255.255.255.0";
	elif pfxlen == 32:
		ipnetwork = ipaddr + "/255.255.255.255";
	
	return ipnetwork

##################################################################
# These functions test various peculiarities of the NFS
# file system
##################################################################
def nfstool_run(client, args):
	return nfs_run(client, nfstool + " " + args)

def __nfstool_run(client, args):
	return __nfs_run(client, nfstool + " " + args)

def nfs_test_createfile(client, dir):

	tf = dir + "/testfile";

	# Open a file with O_CREAT.
	journal.beginTest(None, "create file");
	if nfstool_run(client1, "create-file " + tf):
		__nfs_run(client1, "/bin/rm -f " + tf)
		journal.success()

	# Open a file with O_CREAT|O_EXCL, twice.
	journal.beginTest(None, "Create file with O_EXCL, twice");
	journal.info("the first call should succeed, the second one should fail")
	if not __nfstool_run(client1, "create-file -x " + tf):
		journal.failure("First file open with O_EXCL failed (should have succeeded)")
	elif __nfstool_run(client1, "create-file -x " + tf):
		journal.failure("Second file open with O_EXCL succeeded (should have failed)")

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_writefile(client, dir):

	tf = dir + "/testfile";

	journal.beginTest(None, "write to file")
	if not __nfs_run(client, "/bin/dd if=/dev/zero of=%s bs=1k count=4k" % tf):
		journal.failure("Failed to write to file")

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_chown(client, dir):

	tf = dir + "/testfile"

	journal.beginTest(None, "change file's ownership")
	if nfs_run(client, "touch " + tf):
		nfs_run(client, "/bin/chown --changes nobody " + tf)

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_chmod(client, dir):

	tf = dir + "/testfile"

	journal.beginTest(None, "change file's permissions")
	if nfs_run(client, "touch " + tf):
		nfs_run(client, "/bin/chmod --changes 0600 " + tf)

	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_silly_rename(client, dir):

	src = dir + "/testfile1"
	dst = dir + "/testfile2"

	journal.beginTest(None, "Verify silly-rename semantics")
	journal.info("Open dst, rename src to dst, verify both files")
	nfstool_run(client, "silly-rename %s %s" % (src, dst))
	nfs_run(client1, "/bin/rm -f " + src)
	nfs_run(client1, "/bin/rm -f " + dst)

	journal.beginTest(None, "Verify silly-rename semantics #2")
	journal.info("Open dst, rename src to dst, verify both files. Leave src open the whole time")
	nfstool_run(client, "silly-rename -x %s %s" % (src, dst))
	nfs_run(client1, "/bin/rm -f " + src)
	nfs_run(client1, "/bin/rm -f " + dst)

def nfs_test_silly_unlink(client, dir):

	tf = dir + "/testfile"

	journal.beginTest(None, "Verify silly-unlink semantics")
	journal.info("Open testfile, unlink it, verify content")
	nfstool_run(client, "silly-unlink " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_socket(client, dir):

	tf = dir + "/mysock"

	journal.beginTest(None, "Verify socket creation")
	nfstool_run(client, "create-special -t socket -m 0644 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_fifo(client, dir):

	tf = dir + "/myfifo"

	journal.beginTest(None, "Verify FIFO creation")
	nfstool_run(client, "create-special -t fifo -m 0644 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_chrdev(client, dir):

	tf = dir + "/devnull"

	journal.beginTest(None, "Verify chardev creation")
	nfstool_run(client, "create-special -t chrdev -m 0644 -d 1:3 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_blkdev(client, dir):

	tf = dir + "/devloop"

	journal.beginTest(None, "Verify blockdev creation")
	nfstool_run(client, "create-special -t blkdev -m 0600 -d 7:0 " + tf)
	nfs_run(client1, "/bin/rm -f " + tf)

def nfs_test_symlink(client, dir):

	link = dir + "/imasymlink"
	target = dir + "/testfile"
	basename = "testfile"

	journal.beginTest(None, "Verify symlink operation")
	if not client.sendfile(target, data = bytearray("imadoofus")):
		journal.failure("unable to write target file")
		return False

	if nfs_run(client, "/bin/ln -s %s %s" % (basename, link)):
		st = client.recvfile(link)
		if not st or str(st.buffer) != "imadoofus":
			journal.failure("problem verifying file content through symlink")

	journal.beginTest(None, "Verify symlink operation #2")
	if __nfs_run(client, "/bin/ln -s randomlink %s" % link):
		journal.failure("/bin/ln -s on an existing symlink did not fail")

	nfs_run(client1, "/bin/rm -f " + link)
	nfs_run(client1, "/bin/rm -f " + target)

	# TBD: verify behavior of symlinks pointing outside the exported directory

def nfs_test_hardlink(client, dir):

	link = dir + "/imahardlink"
	target = dir + "/testfile"
	basename = "testfile"

	journal.beginTest(None, "Verify hardlink operation")
	if not client.sendfile(target, data = bytearray("imadoofus")):
		journal.failure("unable to write target file")
		return False

	if nfs_run(client, "/bin/ln %s %s" % (target, link)):
		st = client.recvfile(link)
		if not st or str(st.buffer) != "imadoofus":
			journal.failure("problem verifying file content through hardlink")

	journal.beginTest(None, "Verify hardlink operation #2")
	if __nfs_run(client, "/bin/ln %s %s" % (target, link)):
		journal.failure("/bin/ln on an existing hardlink did not fail")

	nfs_run(client1, "/bin/rm -f " + link)
	nfs_run(client1, "/bin/rm -f " + target)


##################################################################
# General NFS mount testing
##################################################################
def nfs_test_mount():
	global client1, client2, server

	journal.beginGroup("mount")

	exports_data = '''
/srv/nfs/dir1   *(ro,no_subtree_check)
/srv/nfs/dir2   *(rw,no_root_squash,no_subtree_check)
/srv/nfs/dir3   *(rw,no_subtree_check)
'''

	nfs_write_verify_exports(server, exports_data)

	journal.beginTest(None, "verify that we can mount from server by name")
	__nfs_verify_mount(client1, "nfs-server", "dir1");

	nfs_mount_should_succeed(client1, server.ipaddr, "dir1")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir3")
	nfs_mount_should_fail(client1,    server.ipaddr, "dir4")

	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "vers=2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "vers=3")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=4")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,nolock")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,nolock")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,udp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,udp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,proto=tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,proto=udp")

	# TBD: Mounting /srv/nfs/dir1/../../../etc should fail


def nfs_test_exports():

	global client1, client2, server

	journal.beginGroup("export-flags")

	exports_data = '''
/srv/nfs/dir1	*(ro,subtree_check)
/srv/nfs/dir2	*(rw,no_root_squash,subtree_check)
/srv/nfs/dir3	*(rw,subtree_check)
/srv/nfs/dir4	*(rw,root_squash,anonuid=60000,subtree_check)
'''

	nfs_write_verify_exports(server, exports_data)
	nfs_verify_readonly_slow("dir1")

	for options in [None, "vers=2", "vers=3", "vers=4"]:
		# Better safe than sorry
		options = nfs_join_mount_options(options, "intr");

		journal.beginTest(None, "verify that dir1 is exported read-only (mounted with options %s)" % options)
		nfs_verify_readonly("dir1", options);

		journal.beginTest(None, "verify that dir2 is exported read-write (mounted with options %s)" % options)
		nfs_verify_readwrite("dir2", options, 0, 0);

		journal.beginTest(None, "verify that dir3 is exported read-write with root squash (mounted with options %s)" % options)
		nfs_verify_readwrite("dir3", options, 65534, 65534);

		journal.beginTest(None, "verify that dir4 is exported read-write with anonuid=60000 (mounted with options %s)" % options)
		nfs_verify_readwrite("dir4", options, 60000, 65534);

	journal.beginGroup("export-matching")

	##################################################################
	# Test IP prefix matching
	##################################################################
	nfs_verify_exports_matching("match-ipaddr", client1, client1.ipaddr)
	nfs_verify_exports_matching("match-ip-prefix8", client1, __nfs_ipv4_prefix(client1.ipaddr, 8))
	nfs_verify_exports_matching("match-ip-prefix16", client1, __nfs_ipv4_prefix(client1.ipaddr, 16))
	nfs_verify_exports_matching("match-ip-prefix24", client1, __nfs_ipv4_prefix(client1.ipaddr, 24))
	nfs_verify_exports_matching("match-ip-prefix32", client1, __nfs_ipv4_prefix(client1.ipaddr, 32))
	nfs_verify_exports_matching("match-ip-netmask8", client1, __nfs_ipv4_netmask(client1.ipaddr, 8))
	nfs_verify_exports_matching("match-ip-netmask16", client1, __nfs_ipv4_netmask(client1.ipaddr, 16))
	nfs_verify_exports_matching("match-ip-netmask24", client1, __nfs_ipv4_netmask(client1.ipaddr, 24))
	nfs_verify_exports_matching("match-ip-netmask32", client1, __nfs_ipv4_netmask(client1.ipaddr, 32))

	##################################################################
	# Test hostname matching
	##################################################################
	nfs_verify_exports_matching("match-fqdn", client1, "client1.testing.opensuse.org")
	nfs_verify_exports_matching("match-domain", client1, "*.testing.opensuse.org")


def nfs_test_fileops():

	global client1, client2, server

	journal.beginGroup("fileops-init")

	exports_data = '''
/srv/nfs/dir1	*(rw,no_root_squash,subtree_check)
'''
	nfs_write_verify_exports(server, exports_data)

	for options in ["vers=2", "vers=3", "vers=4"]:
		# Better safe than sorry
		options = nfs_join_mount_options(options, "intr");

		journal.beginGroup("fileops-%s" % options)

		journal.beginTest(None, "Mounting dir with options %s" % options)
		if not nfs_do_mount(client1, server.ipaddr, "dir1", options):
			journal.info("Skipping fileops tests for these options - cannot mount directory");
			continue;

		clientdir = __nfs_client_file("dir1")
		nfs_test_createfile(client1, clientdir)
		nfs_test_writefile(client1, clientdir)
		nfs_test_chown(client1, clientdir)
		nfs_test_chmod(client1, clientdir)
		nfs_test_silly_rename(client1, clientdir)
		nfs_test_silly_unlink(client1, clientdir)
		nfs_test_socket(client1, clientdir)
		nfs_test_fifo(client1, clientdir)
		nfs_test_chrdev(client1, clientdir)
		nfs_test_blkdev(client1, clientdir)
		nfs_test_symlink(client1, clientdir)
		nfs_test_hardlink(client1, clientdir)

		nfs_do_umount(client1, "dir1")

##################################################################
# File locking tests
##################################################################

def nfs_test_wait_grace(node, tf):

	# Before running all the locking tests, make sure that the grace period has
	# expired.
	journal.beginTest("grace-wait", "Make sure the locking grace period has expired")
	if __nfs_run(node, "/usr/bin/nfs lock -t 1 " + tf, 120):
		journal.success();
		ret = True
	else:
		journal.failure("Unable to obtain lock")
		node.run("/sbin/killproc -9 /usr/bin/nfs");
		ret = False

	return ret

def nfs_test_posix_lock1(tf):

	global client1

	journal.beginTest(None, "Grab a shared POSIX lock")
	nfs_run(client1, "/usr/bin/nfs lock -t 1 " + tf)

def nfs_test_posix_lock2(tf):

	global client1

	journal.beginTest(None, "Grab an exclusive POSIX lock")
	nfs_run(client1, "/usr/bin/nfs lock -t 1 -x " + tf)

def nfs_test_posix_lock3(tf):

	global client1

	journal.beginTest(None, "Lock and unlock, then make sure GETLK reports no more locks")
	nfs_run(client1, "/usr/bin/nfs lock -t 1 -u " + tf)

def nfs_test_posix_lock4(tf):

	global client1

	journal.beginTest(None, "Grab a sequence of adjacent locks, unlock whole range, and make all locks are gone")
	nfs_run(client1, "/usr/bin/nfs lock -t 1 -s -u " + tf)

def nfs_test_posix_lock5(tf):

	global client1, client2

	# Only run this test if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.beginTest(None, "Grab shared POSIX locks on two clients")

	# Grab one lock on client1, holding that for 5 seconds
	if not nfs_run_background(client1, "/usr/bin/nfs lock -t 5 " + tf):
		journal.failure("Unable to run command in the background")

	# Wait for 1 second to make sure this guy has really had the time to grab the
	# lock
	time.sleep(1)

	# We grab a second shared lock on client2, and hold that for 1 second.
	# In case we block for some reason, we run the command with a 3 second
	if not __nfs_run(client2, "/usr/bin/nfs lock -t 1 " + tf, timeout = 3):
		journal.failure("Failed to grab shared lock on second client")
		client1.waitAll()
		return

	if not nfs_wait(client1):
		journal.failure("Failed to grab shared lock on first client")
		return

	journal.success()

def nfs_test_posix_lock6(tf):

	global client1, client2

	# Only run this test if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.beginTest(None, "Grab exclusive POSIX locks on two clients")

	# Grab one lock on client1, holding that for 10 seconds
	if not nfs_run_background(client1, "/usr/bin/nfs lock -t 10 -x " + tf):
		journal.failure("Unable to run command in the background")
		return

	# Wait for 1 second to make sure this guy has really had the time to grab the
	# lock
	time.sleep(1)

	journal.info("Try to grab shared lock on second client, nonblocking - this should fail")
	if __nfs_run(client2, "/usr/bin/nfs lock -t 1 -n " + tf, timeout = 1):
		journal.failure("Grabbing the shared lock on second client succeeded!")
		client1.waitAll()
		return

	journal.info("Unable to grab lock on second client: good")

	journal.info("Try to grab shared lock on second client, blocking - this should block, then succeed")
	if __nfs_run(client2, "/usr/bin/nfs lock -t 1 " + tf, timeout = 20):
		journal.failure("Blocking lock never acquired")
		client1.waitAll()
		return

	if not nfs_wait(client1):
		journal.failure("Failed to grab exclusive lock on first client?!")
		return

	journal.success()

def nfs_test_flock1(tf):

	global client1

	journal.beginTest(None, "Grab a shared FLOCK lock")
	nfs_run(client1, "/usr/bin/nfs lock -t 1 -b " + tf)

def nfs_test_flock2(tf):

	global client1

	journal.beginTest(None, "Grab a exclusive FLOCK lock")
	nfs_run(client1, "/usr/bin/nfs lock -t 1 -x -b " + tf)

def nfs_test_flock3(tf):

	global client1, client2

	# Only run this test if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.beginTest(None, "Grab shared FLOCK locks on two clients")

	# Grab one lock on client1, holding that for 5 seconds
	if not nfs_run_background(client1, "/usr/bin/nfs lock -t 5 -b " + tf):
		journal.failure("Unable to run command in the background")

	# Wait for 1 second to make sure this guy has really had the time to grab the
	# lock
	time.sleep(1)

	# We grab a second shared lock on client2, and hold that for 1 second.
	# In case we block for some reason, we run the command with a 3 second
	if not __nfs_run(client2, "/usr/bin/nfs lock -t 1 -b " + tf, timeout = 3):
		journal.failure("Failed to grab shared lock on second client")
		client1.waitAll()
		return

	if not nfs_wait(client1):
		journal.failure("Failed to grab shared lock on first client")
		return

	journal.success()

def nfs_test_locking():

	global client1, client2, server

	journal.beginGroup("locking-init")

	exports_data = '''
/srv/nfs/dir1	*(rw,no_root_squash,subtree_check)
'''
	nfs_write_verify_exports(server, exports_data)

	for options in ["vers=2", "vers=3", "vers=4"]:
		# Better safe than sorry
		options = nfs_join_mount_options(options, "intr");

		journal.beginGroup("locking-%s" % options)

		journal.beginTest(None, "Mounting dir with options " + options)
		if not nfs_do_mount(client1, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			continue;

		if not nfs_do_mount(client2, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			nfs_do_umount(client1, dir)
			continue;

		testfile = __nfs_client_file("dir1") + "/testfile"
		if nfs_test_wait_grace(client1, testfile):
			nfs_test_posix_lock1(testfile)
			nfs_test_posix_lock2(testfile)
			nfs_test_posix_lock3(testfile)
			nfs_test_posix_lock4(testfile)
			nfs_test_posix_lock5(testfile)
			nfs_test_posix_lock6(testfile)

			# FIXME: we may want to kill any leftover nfs processes on both clients at this point

			nfs_test_flock1(testfile)
			nfs_test_flock2(testfile)
			nfs_test_flock3(testfile)
		else:
			journal.warning("Skipping all locking tests")

		nfs_run(client1, "rm -f " + testfile)

		nfs_do_umount(client1, "dir1")
		nfs_do_umount(client2, "dir1")

##################################################################
# Ensure that file attributes are validated when reopening a
# file (also called close-to-open (cto) consistency
##################################################################
def nfs_test_cto(tf):

	global client1, client2

	journal.beginTest("cto", "Test close-to-open consistency")

	journal.info("On client1, write 'frank' to the testfile");
	__nfs_run(client1, "echo -n frank >" + tf)

	journal.info("On client2, append 'zappa' to the testfile");
	__nfs_run(client2, "echo -n zappa >>" + tf)

	# Expect the *first* client to revalidate attrs when reopening
	# the file, and discard its cache. IOW the current file content, 
	# which is "frankzappa", should be visible on the first client,
	# too.
	journal.info("Read the test file on client1")
	status = __nfs_run(client1, "cat " + tf)
	if not(status):
		journal.failure("unable to read testfile on client1")
	else:
		after = str(status.stdout)
		if after == "frankzappa":
			journal.success("Great: file contains \"frankzappa\"")
		else:
			journal.failure("Too bad: file contains \"%s\" (expected \"frankzappa\")" % after)

##################################################################
# Test mmap/lock coherence behavior
##################################################################
def __nfs_test_lock_coherence(tf, mode):

	global client1, client2

	# Run mmap2 with
	#  16 slots (one slot is page sized)
	#  32 iterations
	#  2min timeout
	# Mode is a combination of -m and -s:
	#  -m	If given, mmap the file into memory.
	#	If not given, use read/write
	#  -s	If given, use fsync/msync to flush modifications to server before unlock
	#	If not given, expect the kernel to do that as part of the unlock
	command = "/usr/bin/nfs mmap2 -c 16 -i 32 -t 120 %s " % mode

	# Clean up from previous runs
	if not nfs_run(client1, "rm -f " + tf):
		journal.info("This should not have failed; something's really wrong")
		return False

	# On client1, start the mmap challenger
	# The -w option instructs the challenger to sleep for 500ms
	# while waiting for the responder to catch up
	journal.info("Starting the challenger on client1")
	if not nfs_run_background(client1, command + "-w 500 " + tf):
		return False

	# The challenger creates the test file, then locks it
	# (it should really create a temp file, lock it, then move it to the
	# final path).
	journal.info("Waiting for challenger to start")
	ready = False
	for n in range(0, 10):
		if __nfs_run(client1, "test -f " + tf):
			journal.info("ready!")
			ready = True
			break
		journal.info("snore...")
		time.sleep(1)

	if not ready:
		journal.failure("challenger did not start")
		return False

	time.sleep(1)

	# On client2, start the responder.
	# The -r option puts the tool in responder mode
	journal.info("Starting the responder on client2")
	if not __nfs_run(client2, command + "-r " + tf):
		journal.failure("responder returned error")
		return False

	status = nfs_wait(client1)
	if not status:
		journal.failure("challenger exited with error")
		return False

	return True

def nfs_locktest_cleanup(tf):
	# Something went wrong. Clean up
	__nfs_run(client1, "/sbin/killproc -9 /usr/bin/nfs")
	client1.waitAll()

	__nfs_run(client2, "/sbin/killproc -9 /usr/bin/nfs")
	client2.waitAll()

	__nfs_run(client1, "rm -f " + tf)

def nfs_test_lock_coherence(tf):

	# Only run these tests if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.info('''
This set of tests validates the data coherence of NFS.

A file of 16 page-sized slots is accessed simultaneously by a challenger 
and a responder process. The challenger process writes a "challenge" word
to each slot, and expects the responder to echo this back. Both processes
use POSIX locks to prevent concurrent access during the read/write operations.

The file will be accessed either using regular read/write system calls,
or by mapping it into memory using mmap. Additional synchronization can
be provided by using fsync/msync.
''')

	# Turn on lockd debugging
	# __nfs_run(client2, "/usr/sbin/rpcdebug -m nlm all")

	journal.beginTest(None, "locked read/write coherence")
	if not __nfs_test_lock_coherence(tf, ""):
		nfs_locktest_cleanup(tf)

	journal.beginTest(None, "locked read/write/fsync coherence")
	if not __nfs_test_lock_coherence(tf, "-s"):
		nfs_locktest_cleanup(tf)

	journal.beginTest(None, "locked mmap coherence")
	if not __nfs_test_lock_coherence(tf, "-m"):
		nfs_locktest_cleanup(tf)

	journal.beginTest(None, "locked mmap/msync coherence")
	if not __nfs_test_lock_coherence(tf, "-m -s"):
		nfs_locktest_cleanup(tf)

	# __nfs_run(client2, "/usr/sbin/rpcdebug -m nlm -c all")

def nfs_test_coherence():

	global client1, client2, server

	journal.beginGroup("coherence-init")

	exports_data = '''
/srv/nfs/dir1	*(rw,no_root_squash,subtree_check)
'''
	nfs_write_verify_exports(server, exports_data)

	for options in ["vers=2", "vers=3", "vers=4"]:
		# Better safe than sorry
		options = nfs_join_mount_options(options, "intr");

		journal.beginGroup("coherence-%s" % options)

		journal.beginTest(None, "Mounting dir with options " + options)
		if not nfs_do_mount(client1, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			continue;

		if not nfs_do_mount(client2, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			nfs_do_umount(client1, dir)
			continue;

		testfile = __nfs_client_file("dir1") + "/testfile"
		if nfs_test_wait_grace(client1, testfile):
			nfs_test_cto(testfile)
			nfs_test_lock_coherence(testfile)
		else:
			journal.warning("Skipping all coherence tests")

		nfs_run(client1, "rm -f " + testfile)

		nfs_do_umount(client1, "dir1")
		nfs_do_umount(client2, "dir1")

def main():
	nfs_init_all()
	nfs_test_mount()
	nfs_test_exports()
	nfs_test_fileops()
	nfs_test_locking()
	nfs_test_coherence()

	journal.writeReport()

main()
